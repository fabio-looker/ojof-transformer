# Warning:  This file is programatically generated (Your changes will be overwritten)
# Orion by Fabio
# Generator v<<:x.generator.v>> (<<:x.generator.date>>)
# Generated on <<:(new Date()).toISOString().slice(0,10)>>


<<* x.views :view:v>>
<<:recurView({view})>>
<<*>>
<<!function recurView({view,name,label}){
		var out="";
		name = name||[view._view];
		label = [view.label||name2label(view._view)];
		>>
		view: <<:name.join("__")>> {
			label: "<<:label_prefix.concat(label || name2label(name)).join(" > ")"
			dimension: placeholder {}
		}
		<<* equijoin(				
				view.foreign_keys, fk=>fk._foreign_key, "fk",
				x.views, v=>v.primary_key._primary_key, "view"
			) :rel:r >>
		<<:recurView({
				view:rel.view,
				name:name.concat(rel.fk.as||rel.view._view),
				label:label.concat(rel.fk.label || name2label(rel.fk.as) || rel.view.label || name2label(rel.view._view))
			})
		>>
		<<*>>
<<! return out;};>>
<<!function equijoin(arrL,keyL,asL,arrR,keyR,asR){
		const idx = arrL.reduce(
				(idx, objL) => 
						keyL(objL) === undefined
						?idx
						:idx.set(keyL(objL), [...(idx.get(keyL(objL))||[]), ...[objL]]) 
				,new Map
			)
 		const matches = 
				arrR
				.map(objR =>
						keyR(objR) === undefined
						? []
						: idx.get(keyR(objR))
								.map(objL => ({[asL]:objL, [asR]]:objR}))
								.reduce((a,b)=>a.concat(b),[])
					)
				.reduce((a,b)=>a.concat(b),[])
		return matches
};
function name2label(str){return str.replace?str.replace(/_+([a-Za-z])/g,m=>(" "+m[1].toUpperCase())):undefined;};
>>