{
	function assignSuper(obj,type,name){
			if(typeof obj != "object" || !type || !name){return {}}
			obj["_"+type]=name
			Object.values(obj).forEach(subObj => assignSuper(subObj, type, name)) 
			return obj;
		}
	function groupDeclarations(params){
			var collection = {};
			params.forEach(p=>{
					assignSuper(p.value,p.type,p.name)
					if(p.name){		
							if(!collection[p.type]){
									collection[p.type]={};
									collection[p.type+'s']=[];
								}
							collection[p.type+'s'].push(p.value);
							collection[p.type][p.name]=p.value;
						} else {
							if (!	collection[p.type]){
									collection[p.type] = p.value
								}
							else if(collection[p.type].push){
									collection[p.type].push(p.value)
								}
							else{
									collection[p.type] = [collection[p.type]]
									collection[p.type].push(p.value)
							}
						}
				})
			return collection
		}
}

declarationSet = ds:(declaration)* {return groupDeclarations(ds);}

declaration  = _ d:( 
					labeledObject
                    / unlabeledObject
                    / sqlAttribute
                    / htmlAttribute
                    / arrayAttribute
                    / stringAttribute
                    / atomAttribute
                    ) _ {return d}

labeledObject   = type:atom _ ":" _ name:atom _ val:object {return {type:type,name:name,value:val}}
unlabeledObject = type:atom _ ":" _             val:object {return {type:type,name:undefined,value:val}}
sqlAttribute 	= type:sqlAtom _ ":" _ 	        val:doubleSemiBlock   {return {type:type,name:undefined,value:val}}
htmlAttribute 	= type:htmlAtom _ ":" _ 		val:doubleSemiBlock    {return {type:type,name:undefined,value:val}}
arrayAttribute  = type:atom _ ":" _  			val: (emptyList / atomStarList / stringList) {return {type:type,name:undefined,value:val}}
stringAttribute = type:atom _ ":" _ 			val:string    {return {type:type,name:undefined,value:val}}
atomAttribute   = type:atom _ ":" _ 			val:atom    {return {type:type,name:undefined,value:val}}


object = "{" _ d:declarationSet _ "}" {return d}

emptyList = "[" _ "]" {return [] }
atomStarList = "[" _ first:atomStar rest:(_ "," _ atomStar)* _ "]" {return [first].concat(rest.map(r=>r[3]))}  
stringList = "[" _ first:string rest:(_ "," _ string)* _ "]" {return [first].concat(rest.map(r=>r[3]))}

atom = chars:[-_a-zA-Z0-9.]+ {return chars.join('')}
atomStar = chars:[-_a-zA-Z0-9.]+"*"? {return chars.join('')}
sqlAtom = "sql" chars:[-_a-zA-Z0-9]* {return "sql"+chars.join('')}
htmlAtom = "html" chars:[-_a-zA-Z0-9]* {return "html"+chars.join('')}

doubleSemiBlock = chars:([^;] / ( ";" [^;] ))*  ";;" {return chars.join('')}
//Hmm: Is a block whose last character is a ';' accepted by native parser?

string
  = "\"" chars:( stringLiteralCharacter / stringEscapedCharacter )* "\""
    {return chars.join('')}
  stringLiteralCharacter = [^"\\]
  stringEscapedCharacter = "\\" ch:[\"\\] {return ch;}



_ = (whitespace / comment)* {return [];}

whitespace = [ \t\n\r]+ {return undefined;}
comment = "#" chars:[^\n\r]* [\n\r]+