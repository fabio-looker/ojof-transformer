<<!
function viewFromName(name){return x.views.concat(x.codims).find(v=>v.name==name)};
function righterViews(baseView) {
		return viewsInDirection(baseView,"right",10)
	};
function lefterViews(baseView){
		return viewsInDirection(baseView,"left",10)
	};
function rightViews(baseView) {
		return viewsInDirection(baseView,"right",1)
	};
function leftViews(baseView){
		return viewsInDirection(baseView,"left",1)
	};
function viewsInDirection(baseView,direction,depth){
		baseView = typeof baseView == "string" ? viewFromName(baseView) : baseView;
		return (
				recurViewsInDirection(baseView,direction,depth)
				.map(v=>v.name)
				.filter(unique)
				.map(viewFromName)
			);
};
function recurViewsInDirection(baseView,dir,remainingRecursion){
		var oppDir=(dir=="left"?"right":"left");
		var immediateViews = 
				[]
				.concat(
						x.normalizedRelationships
						.filter(rel=>rel[oppDir+"ViewName"]==baseView.name)
						.map(rel=>viewFromName(rel[dir+"ViewName"]))
					)
				.concat(dir=="right" ?
						(baseView.fields||[])
						.filter(f=>f.codim)
						.map(f=>viewFromName(f.codim))
						:[]
					);
		return ((immediateViews.length && remainingRecursion>0)
				?(immediateViews
				  .map(v=>recurViewsInDirection(v,dir,remainingRecursion-1))
				  .reduce(flatten,immediateViews)
				)
				: []
			);
	};
function sqlString(s){
		switch (x.dialect){
				case 'Redshift': /* ??? Thanks Amazon.... http://docs.aws.amazon.com/redshift/latest/dg/r_Literals.html */
				case 'BigQuery Standard': /* https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#string-and-bytes-literals */
						return "'"+(s||'').replace(/\\/g,"\\\\").replace(/'/g,"\\'")+"'"
			}
	};
function measureNames(view){
		return (["smy","sum","avg","min","max","first","last","list"]
				.map(measureType=>view.fields.map(field=>field[measureType] && measureType+"_"+field.name))
				.reduce(flatten,["count_pk"])
				.filter(truthy)
			)
	}
function dimensionNames(viewOrField){
		return (
				[{flag:"dim", prefix:"dim_", suffix:""}]
				.concat(x.timeframes.map(t=>({flag:"ddg", prefix:"ddg_", suffix:"_"+t})))
				.map(dimensionType=>
						(viewOrField.fields || [viewOrField])
						.map(field=>
								field[dimensionType.flag] && dimensionType.prefix+field.name+dimensionType.suffix
							)
					)
				.reduce(flatten,viewOrField.pk?["dim_pk"]:[])
				.filter(truthy)
			)
	};
function codimNames(codim){
		return (codim.type!="date"
				? [codim.name]
				: x.timeframes.map(t=>codim.name+"_"+t)
			);
	};
function if_if_ViewShouldBeJoinedLiquid(view){
		var out="";
		>>	
		{%if '0'=='1'
			<<* measureNames(view) :msr >>or <<:view.mName>>.<<:msr>>._in_query <<*>>
			<<* dimensionNames(view) :dim >>or <<:view.dName>>.<<:dim>>._in_query <<*>>
			<<* lefterViews(view) :left:l >>
			<<* measureNames(left) :msr >>or <<:left.mName>>.<<:msr>>._in_query <<*>>
			<<* dimensionNames(left) :dim >>or <<:left.dName>>.<<:dim>>._in_query <<*>>
			<<*>>
		%}
		{%if '0'=='1'
			<<* measureNames(view) :msr >>or <<:view.mName>>.<<:msr>>._in_query <<*>>
			<<* dimensionNames(view) :dim >>or <<:view.dName>>.<<:dim>>._in_query <<*>>
			<<* righterViews(view) :right:r >>
			<<?right.codim>>
			<<* codimNames(right) :codim >>or <<:right.name>>.<<:codim>>._in_query <<*>>
			<<??>>
			<<* measureNames(right) :msr >>or <<:right.mName>>.<<:msr>>._in_query <<*>>
			<<* dimensionNames(right) :dim >>or <<:right.dName>>.<<:dim>>._in_query <<*>>
			<<?>>
			<<*>>
		%}
		<<! return out;
	};
	function if_takeDimFromMsr(view){
			var out="";
			>>	
			{%if '0' == '1'
				<<* lefterViews(view) :left>>
				<<* measureNames(left) :msr >>or <<:left.mName>>.<<:msr>>._in_query <<*>>
				<<* dimensionNames(left) :dim >>or <<:left.dName>>.<<:dim>>._in_query <<*>>
				<<*>>
			%}
			<<! return out;
		};
>>
# Warning:  This file is programatically generated (Your changes will be overwritten)
# Authored by Fabio
# Generated by <<:x.generator.name>> 
# v<<:x.generator.v>> (<<:x.generator.date>>)
# Generated on <<:(new Date()).toISOString().slice(0,10)>>
# https://fabio-looker.github.io/ojof-builder/#o=<<:rison.encode_uri(x.original)>>

<<?x.connectionName.trim()>>connection: "<<:x.connectionName>>"<<?>>
explore: <<:x.explore.name>> {
	label:"<<:x.explore.label>>"
	from: <<:x.explore.name>>
	view_name: ojof
	
	<<:x.explore.other>>

	## Measure table joins
	<<* x.views :view:v >>
	join: <<:view.mName>> {
		from: <<:view.name>>
		fields:[require, measures*]
		relationship: one_to_one
		sql:				
			<<:if_if_ViewShouldBeJoinedLiquid(view)>>
				/* Self|lefter & self|righter both in query. Bring in MSR <<:view.mName>> */
					FULL OUTER JOIN <<:view.name>> AS <<:view.mName>>
					ON <<? x.dialect=="BigQuery Standard" >> FALSE
					<<?? x.dialect=="Redshift" >>/* FALSE -- Redshift only allows FOJ on merge joins, which require dist & sort key equality*/
						<<:view.mName>>.<<:view.rs.dist>> = ${ojof.none}
						AND <<:view.mName>>.<<:view.rs.sort>> = ${ojof.none}
						<<* x.views.filter(prior=>prior.n<view.n) :prior:p >>
						<<: if_if_ViewShouldBeJoinedLiquid(prior)>>
							AND <<:view.mName>>.<<:view.rs.dist>> = <<:prior.mName>>.<<:prior.rs.dist>>
							AND <<:view.mName>>.<<:view.rs.sort>> = <<:prior.mName>>.<<:prior.rs.sort>>
						{% endif %}{% endif %}
						<<*>>
					<<?>>
			{% else %}	/* Self|righter NOT in query. Prevent MSR <<:view.mName>> */ {% endif %}
			{% else %}	/* Self|lefter NOT in query. Prevent MSR <<:view.mName>> */ {% endif %}
		;;
	}
	<<*>>

	#Selected "Dimension table" joins
	<<* x.views :view:v >>
	join: <<:view.dName>> {
		from: <<:view.name>>
		fields:[require, dimensions*, codim_selectors*]
		relationship:many_to_one
		required_joins:[
			<<:view.mName>><<* leftViews(view) :left:l>>, <<:left.dName>><<*>>
		]
		sql:
			<<:if_if_ViewShouldBeJoinedLiquid(view)>>
				<<:if_takeDimFromMsr(view)>>
				/*Lefter & self|righter in query. Dim <<:view.dName>> join required*/
					LEFT JOIN <<:view.name>> AS <<:view.dName>> 
						ON <<:view.dName>>.<<:view.pk.key>> =
						COALESCE(<<:view.mName>>.<<:view.pk.key>>
						<<* x.normalizedRelationships.filter(r=>r.rightViewName==view.name) :rel>>
							<<!let left=viewFromName(rel.leftViewName);>>
							<<: if_if_ViewShouldBeJoinedLiquid(left) >>
								,${ojof.<<:left.dName>>}.<<:rel.foreignKey>>
							{% endif %}{% endif %}
						<<*>>
						)
						
					<<? x.dialect=="Redshift" && view.rs.distgroup >>
					--Distkey equality (unless incompatible parents are in query)
					<<* leftViews(view).filter(l=>l.rs.distgroup!=view.rs.distgroup) :badLeftView>>
					<<: if_if_ViewShouldBeJoinedLiquid(badLeftView) >>
						/*<<:badLeftView.name>> is in query and has distgroup <<:badLeftView.rs.distgroup>>. Prevent distkey equality
						{% endif %}{% if '1'=='0' %}*/
					{% endif %}{% endif %}
					<<*>>
					AND <<:view.dName>>.<<:view.rs.dist>> =
						COALESCE(<<:view.mName>>.<<:view.rs.dist>>
						<<* leftViews(view) :left>>
							<<: if_if_ViewShouldBeJoinedLiquid(left) >>
								, ${ojof.<<:left.dName>>}.<<:left.rs.dist>>
							{% endif %}{% endif %}
						<<*>>
						)
					<<?>>
					-- End conditional distkey */
				{% else %}/* Lefter NOT in query. Use measure join for DIM <<:view.dName>> fields */{% endif %}
			{% else %}	/* Self|righter NOT in query. Prevent DIM <<:view.dName>> */ {% endif %}
			{% else %}	/* Self|lefter NOT in query. Prevent DIM <<:view.dName>> */ {% endif %}
			
		;;
	}
	<<*>>
	
	##Codim joins
	<<* x.codims :codim>>
	join: <<:codim.name>> {
		sql: ;;
		required_joins:[
			<<*x.views.filter(v=>v.fields.some(f=>f.codim==codim.name)) :view:v>>
			<<?v>0>>,<<?>> <<:view.dName>> <<*>>
		]
		relationship: one_to_one
	}
	<<*>>
}

#"Base" (empty) View
view: <<:x.explore.name>> {
	view_label: "[<<:x.explore.label>>]"
	<<? x.dialect=="BigQuery Standard">> #BQ
	sql_table_name: (SELECT base FROM (SELECT null as base) as basetable WHERE base IS NOT NULL);;
	<<?? x.dialect=="Redshift">> #Redshift
	derived_table: {
		sql: (SELECT base FROM (SELECT null as base) as basetable WHERE base IS NOT NULL) ;;
		persist_for: "120 hours"
		distribution: "base"
		sortkeys: ["base"]
	}
	<<?>>
	dimension: none {
		hidden: yes
		sql: ${TABLE}.base ;;
	}
	
	# All {TABLE DIM/MSR} defined so you can reference them without
	# without bringing in the join (since we are only referring to the table when we know it will be there,
	# rather than forcing it to be there when we refer to it)
	
	<<* x.views :view >>
	dimension: <<:view.mName>> {
		hidden: yes
		sql:<<:view.mName>>;;
	}
	dimension: <<:view.dName>> {
		hidden: yes
		#Avoid joining a dimension table when dimensions can be taken directly from measure join b/c no lefter views
		sql:<<:if_takeDimFromMsr(view)>><<:view.dName>>{% else %}<<:view.mName>>{% endif %};;
	}
	<<*>>
}

#Codim "views"
<<* x.codims :codim:c>>
view: <<:codim.name>> {
	<<? codim.type=="date">>dimension_group<<??>>dimension<<?>>: <<:codim.name>> {
			view_label: <<? codim.viewLabel=="[Base view]">>"[<<:x.explore.label>>]"<<??>>"<<:codim.viewLabel>>"<<?>>
			<<? codim.type=="date">>
			type: time
			timeframes: [<<:x.timeframes.join(",")>>]
			group_label: "<<:codim.label>>"
			label: " "
			<<??>>
			<<?codim.type>>type: <<:codim.type>><<?>>
			label: "<<:codim.label>>"
			<<?>>
			sql: COALESCE(
				<<* x.views :view:v>>
				<<* view.fields :field:f>>
					<<? field.codim == codim.name >>
						<<:if_if_ViewShouldBeJoinedLiquid(view)>>
							<<? view.fields.filter(field2=>field2.codim==field.codim).length>1 >>
							{% if <<:view.dName>>.switch_<<:codim.name>>._sql == '<<:field.name>>' %}
								 <<?codim.viewLabel==view.label>><<:field.sqlDim>><<??>><<:field.sqlDimWeak>><<?>>,
							{% endif %}
							<<??>>
								 <<?codim.viewLabel==view.label>><<:field.sqlDim>><<??>><<:field.sqlDimWeak>><<?>>,
							<<?>>
						{% endif %}
						{% endif %}
					<<?>>
				<<*>>
				<<*>>
				NULL
			)
			;;
	}
}
<<*>>

# Maybe add this pattern to the generator too?
#
#measure: product_conversion_rate {
#	type: number
#	value_format_name: decimal_3
#	sql: CASE WHEN ${pageviews.count}<>0 THEN ${orders.count} / ${pageviews.count} ELSE NULL END;;
#}
#

#####################################
#
#    "REAL" VIEWS
#
#####################################
<<* x.views :view >>
view: <<:view.name>> {
	label: "<<:view.label>>"
	# Use DT (instead of subselect in sql_table_name) to ensure you can reference ${foo.SQL_TABLE_NAME} if the user tries to use that
	derived_table: {
		sql:
		<<:if_if_ViewShouldBeJoinedLiquid(view)>>
			SELECT * <<!/*TODO: See if query optimizer optimizes this? (It should) If not, specify columns, which is hard, because at the moment, I just have fields, which may recursively expand to arbitrary column references */>>
			FROM <<:view.table>> AS <<:view.name>>
			WHERE 1=1
			<<* view.fields :field:f>>
				<<!/* Push dimension filters into the subselect */>>
				<<* dimensionNames(field) :dim:d>>
						{% if <<:view.dName>>.<<:dim>>._is_filtered %}
							AND {% condition <<:view.dName>>.<<:dim>> %} <<:field.sqlInner>> {% endcondition %}
						{% endif %}
				<<*>>
				<<!/* Push codim filters into the subselect */>>
				<<* x.codims :codim:c>>
					<<? field.codim == codim.name >>
					<<* codimNames(codim) :typedName:t>>
						{% if <<:codim.name>>.<<:typedName>>._is_filtered %}
							<<? view.fields.filter(field2=>field2.codim==field.codim).length>1 >>
							{% if <<:view.dName>>.switch_<<:codim.name>>._sql == '<<:field.name>>'
							%}AND {% condition <<:codim.name>>.<<:typedName>> %}<<:field.sqlInner>>{% endcondition %}
							{% endif %}
							<<??>>
							AND {% condition <<:codim.name>>.<<:typedName>> %}<<:field.sqlInner>>{% endcondition %}
							<<?>>
						{% endif %}
					<<*>>
					<<?>>
				<<*>>
			<<*>>
		{% else %} --No self|righter views in query. Skip view
		SELECT NULL as x {% endif %}
		{% else %} --No self|lefter views in query. Skip view
		SELECT NULL as x {% endif %}
		;;
	}
	
	#
	#  Table aliases
	#
	
	dimension: msr {
		hidden: yes
		sql:${ojof.<<:view.mName>>};;
	}
	dimension: dim {
		hidden: yes
		sql:${ojof.<<:view.dName>>};;
	}
	dimension: require {
		hidden: yes
		sql:Requires MSR <<:view.mName>>;; #SQL is just informational, could be blanked out too
	}
	
	#
	#  Keys
	#
	
	<<?x.dialect=="Redshift">>
	dimension: dist{
		hidden: yes
		sql:${TABLE}.<<:view.rs.dist>>;;
	}
	dimension: sort{
		hidden: yes
		sql:${TABLE}.<<:view.rs.sort>>;;
	}
	<<?>>
	dimension: pk {
		hidden: yes
		sql: ${TABLE}.<<:view.pk.key>>;;
	}
	
	#
	# Measures
	#
	set: measures {
		fields: [require<<*measureNames(view) :msr>>, <<:msr>><<*>>]
	}
	measure: count_pk {
		hidden: <<:view.pk.count ? "no" : "yes">>
		label: "<<:view.label>> Count"
		type: number
		sql: CASE WHEN MIN(${msr}.<<:view.pk.key>>) IS NULL THEN NULL ELSE COUNT(${msr}.<<:view.pk.key>>) END ;;
	}
	<<*view.fields :field>>
	<<?field.smy>>
	measure: smy_<<:field.name>> {
		type: string
		label: "<<:field.label>>"
		<<? x.dialect=="Redshift">>
		sql:	CASE COUNT(<<:field.sqlMsr>>)
				WHEN 0 THEN NULL
				WHEN 1 THEN MIN(<<:field.sqlMsr>>)::VARCHAR
				WHEN 2 THEN
					CASE
					WHEN MIN(<<:field.sqlMsr>>) = MAX(<<:field.sqlMsr>>)
					THEN MIN(<<:field.sqlMsr>>) || ' (x2)'
					ELSE MIN(<<:field.sqlMsr>>)::VARCHAR || ',' 
							|| MAX(<<:field.sqlMsr>>)::VARCHAR
					END
				ELSE
					CASE
					WHEN MIN(<<:field.sqlMsr>>) = MAX(<<:field.sqlMsr>>)
					THEN MIN(<<:field.sqlMsr>>) || ' (x' || COUNT(<<:field.sqlMsr>>) || ')'
					ELSE MIN(<<:field.sqlMsr>>)::VARCHAR || ' ...(+'
							|| TO_CHAR(COUNT(<<:field.sqlMsr>>)-2,'999,999,999,999')|| ')... ' 
							|| MAX(<<:field.sqlMsr>>)::VARCHAR
				END
			END
		;;
		<<?>>
		<<? x.dialect=="BigQuery Standard">>
		sql:	CASE COUNT(<<:field.sqlMsr>>)
				WHEN 0 THEN NULL
				WHEN 1 THEN CAST(MIN(<<:field.sqlMsr>>) as STRING)
				WHEN 2 THEN
					CASE
					WHEN MIN(<<:field.sqlMsr>>) = MAX(<<:field.sqlMsr>>)
					THEN CONCAT(CAST(MIN(<<:field.sqlMsr>>) as STRING), ' (x2)'
					ELSE CONCAT(
							  CAST(MIN(<<:field.sqlMsr>>) as STRING), ',' 
							, CAST(MAX(<<:field.sqlMsr>>) as STRING)
							)
					END
				ELSE
					CASE
					WHEN MIN(<<:field.sqlMsr>>) = MAX(<<:field.sqlMsr>>)
					THEN CONCAT(
							CAST(MIN(<<:field.sqlMsr>>) as STRING),
							' (x',
							CAST(COUNT(<<:field.sqlMsr>>) as STRING),
							')'
						)
					ELSE CONCAT(
							  CAST(MIN(<<:field.sqlMsr>>) as STRING), ' ...(+'
							, CAST(COUNT(<<:field.sqlMsr>>)-2 as STRING), ')... ' 
							, CAST(MAX(<<:field.sqlMsr>>) as STRING)
						)
					END
				END
		;;
		<<?>>
		<<:field.otherLookml>>
	}
	<<?>>
	
	<<?field.sum>>
	measure: sum_<<:field.name>> {
		type: number
		label: "<<:field.label>>: Sum"
		sql: SUM(<<:field.sqlMsr>>) ;;
		<<:field.otherLookml>>
	}
	<<?>>

	<<?field.avg>>
	measure: avg_<<:field.name>> {
		type: number
		label: "<<:field.label>>: Avg"
		sql: AVG(<<:field.sqlMsr>>) ;;
		<<:field.otherLookml>>
	}
	<<?>>

	<<?field.min>>
	measure: min_<<:field.name>> {
		type: <<:field.type>>
		<<?field.type=="date">>
		label: "Earliest <<:field.label>>"
		<<??>>
		label: "<<:field.label>>: Min"
		<<?>>
		sql: MIN(<<:field.sqlMsr>>) ;;
		<<:field.otherLookml>>
	}
	<<?>>

	<<?field.max>>
	measure: max_<<:field.name>> {
		type: <<:field.type>>
		<<?field.type=="date">>
		label: "Latest <<:field.label>>"
		<<??>>
		label: "<<:field.label>>: Max"
		<<?>>
		sql: MAX(<<:field.sqlMsr>>) ;;
		<<:field.otherLookml>>
	}
	<<?>>
	<<?field.first>>
	measure: first_<<:field.name>> {
		type: string
		label: "<<:field.label>>: First"
		<<? x.dialect=="Redshift">>
		sql:
			SUBSTRING( MIN(
				<<?field.type=="number">>LPAD<<??>>RPAD<<?>>(${msr}.<<:field.firstLastBy>>::VARCHAR,20)
				|| '~' || 
				<<:field.sqlMsr>>::VARCHAR
			) FROM 22)
		;;
		<<?>>
		<<? x.dialect=="BigQuery Standard">>
		sql:
			SUBSTR( MIN( CONCAT(
				<<?field.type=="number">>LPAD<<??>>RPAD<<?>>(CAST(${msr}.<<:field.firstLastBy>> as STRING),20)
				, '~' , 
				CAST(<<:field.sqlMsr>> as STRING)
			)), 22)
		;;
		<<?>>
		<<:field.otherLookml>>
	}
	<<?>>
	<<?field.last>>
	measure: last_<<:field.name>> {
		type: string
		label: "<<:field.label>>: Last"
		<<? x.dialect=="Redshift">>
		sql:
			SUBSTRING( MAX(
				<<?field.type=="number">>LPAD<<??>>RPAD<<?>>(${msr}.<<:field.firstLastBy>>::VARCHAR,20)
				|| '~' || 
				<<:field.sqlMsr>>::VARCHAR
			) FROM 22)
		;;
		<<?>>
		<<? x.dialect=="BigQuery Standard">>
		sql:
			SUBSTR( MAX( CONCAT(
				<<?field.type=="number">>LPAD<<??>>RPAD<<?>>(CAST(${msr}.<<:field.firstLastBy>> as STRING),20)
				, '~' , 
				CAST(<<:field.sqlMsr>> as STRING)
			)), 22)
		;;
		<<?>>
		<<:field.otherLookml>>
	}
	<<?>>
	<<?field.list>>
	measure: list_<<:field.name>> {
		type: string
		label: "<<:field.label>>: List"
		<<? x.dialect=="Redshift">>sql: LISTAGG(<<:field.sqlMsr>>,', ') ;;<<?>>
		<<? x.dialect=="BigQuery Standard">>sql: GROUP_CONCAT(<<:field.sqlMsr>>) ;;<<?>>
		<<:field.otherLookml>>
	}
	<<?>>
	<<*>>

	#
	#  Dimensions
	#
	
	set: dimensions {
		fields: [<<:dimensionNames(view).join(", ")>>]
	}
	dimension: dim_pk {
		hidden: <<:view.pk.dim ? "no" : "yes">>
		label: "<<:view.label>> ID"
		sql: ${dim}.<<:view.pk.key>>  /*${<<:view.mName>>.require}*/;;
	}
	<<* view.fields :field>>
	<<?field.dim>>
	dimension: dim_<<:field.name>> {
		<<?field.type>>type: <<:field.type>><<?>>
		label: "<<:field.label>>"
		sql: <<:field.sqlDim>> /*${<<:view.mName>>.require}*/;;
		<<:field.otherLookml>>
	}
	<<?>>
	<<?field.ddg>>
	dimension_group: ddg_<<:field.name>> {
		group_label: "<<:field.label>>"
		label: " "
		type: time
		timeframes: [<<:x.timeframes.join(",")>>]
		sql: <<:field.sqlDim>> /*${<<:view.mName>>.require}*/;;
		<<:field.otherLookml>>
	}
	<<?>>
	<<*>>

	#
	#  Codim selectors
	#
	set: codim_selectors {
		fields: [dim
		<<* x.codims :codim>>
			<<? view.fields.filter(f=>f.codim==codim.name).length>1 >>,switch_ui_<<:codim.name>><<?>>
		<<*>>
		]
	}
	<<* x.codims :codim:c>>
		<<? view.fields.filter(f=>f.codim==codim.name).length>1 >>
		parameter: switch_ui_<<:codim.name>> {
			label: "<<?codim.type=='date'>>Date<<??>>Field<<?>> for <<:codim.label>>"
			type: unquoted
			<<* view.fields.filter(f=>f.codim==codim.name) :field:f>>
			allowed_value: {value:"<<:field.name>>" label:"<<:field.label>>"}
			<<*>>
		}
		dimension: switch_<<:codim.name>> {
			hidden: yes
			sql:{% parameter <<:view.dName>>.switch_ui_<<:codim.name>> %};;
		}
		<<?>>
	<<*>>
}
<<*>>